# v0.2 - Active Verification & Timeout Handling

## ğŸ¯ Obiective

**Focus principal:** Reducerea ratelor de False Positive/Negative prin:
1. **Active Verification** - Confirmare activÄƒ a vulnerabilitÄƒÈ›ilor detectate
2. **Timeout Handling** - Stabilizarea execuÈ›iei pe aplicaÈ›ii SPA complexe

## ğŸ“Š Metrici È›intÄƒ

| Metric | v0.1 | v0.2 Target |
|--------|------|-------------|
| False Positive Rate | ~15% | < 5% |
| Detection Confidence | 50-60% | > 80% |
| SPA Test Success Rate | ~70% | > 95% |
| Timeout Rate | ~25% | < 5% |

## ğŸ” Active Verification System

### Concept

Ãn loc sÄƒ raportÄƒm vulnerabilitÄƒÈ›i la prima detecÈ›ie, acum verificÄƒm fiecare finding prin multiple tehnici independente.

### Nivele de Verificare

```typescript
enum VerificationLevel {
  NONE = 'none',      // Cel mai rapid, fÄƒrÄƒ verificare (pentru scanÄƒri rapide)
  BASIC = 'basic',    // 1 re-test cu acelaÈ™i payload
  STANDARD = 'standard', // 2 tehnici diferite
  FULL = 'full',      // 3+ tehnici, cea mai mare Ã®ncredere
}
```

### Tehnici de Verificare

#### 1. Time-Based Verification
Pentru SQL Injection È™i Command Injection:
- MÄƒsoarÄƒ baseline response time (3 samples)
- InjecteazÄƒ payload cu delay (SLEEP/WAITFOR)
- VerificÄƒ dacÄƒ delay-ul este statistic semnificativ
- RepetÄƒ cu payload-uri diferite pentru confirmare

```typescript
// Exemplu: SQL Injection Time-Based
const analysis = await timeBasedVerifier.performTimingAnalysis(
  page, surface,
  "1' AND SLEEP(2)--",
  2000,  // expected delay
  baseUrl,
  3      // samples
);

if (analysis.isSignificant) {
  // Vulnerability CONFIRMED
}
```

#### 2. Response Diff Verification
Pentru toate tipurile de injection:
- Trimite payload "true" È™i "false" 
- ComparÄƒ rÄƒspunsurile
- DiferenÈ›e semnificative = vulnerability confirmatÄƒ

```typescript
// Boolean-based SQL Injection
const truePayload = "' OR '1'='1";
const falsePayload = "' OR '1'='2";

const diff = compareResponses(trueResult, falseResult);
if (diff.hasDiff && diff.similarity < 0.95) {
  // Vulnerability CONFIRMED
}
```

#### 3. Error Pattern Detection
VerificÄƒ prezenÈ›a error patterns Ã®n rÄƒspuns:
- SQL errors: `mysql_fetch`, `sqlexception`, `sequelize`
- Command errors: `command not found`, `/bin/`
- Path traversal: `root:x:`, `no such file`

### Confidence Scoring

Fiecare vulnerability primeÈ™te un scor de confidence (0-1):

| Verification Result | Confidence |
|--------------------|------------|
| 3+ techniques confirm | 0.95+ |
| 2 techniques confirm | 0.80-0.95 |
| 1 technique confirms | 0.60-0.80 |
| Error patterns only | 0.50-0.60 |
| No confirmation | < 0.50 (filtered) |

### Configurare

```typescript
const verificationConfig: VerificationConfig = {
  level: VerificationLevel.STANDARD,
  minConfidence: 0.7,      // Minimum pentru raportare
  maxAttempts: 3,          // Max Ã®ncercÄƒri per tehnicÄƒ
  attemptTimeout: 15000,   // Timeout per Ã®ncercare
  stopOnConfirm: false,    // ContinuÄƒ pentru mai multÄƒ Ã®ncredere
};
```

## â±ï¸ Timeout Handling

### Problema

AplicaÈ›iile SPA (Angular, React, Vue) au comportament asincron care poate cauza:
- Timeouts false (scan finalizat dar test eÈ™uat)
- DetecÈ›ii ratate (rÄƒspuns API neaÈ™teptat)
- Stare inconsistentÄƒ Ã®ntre teste

### SoluÈ›ia: Adaptive Timeout Manager

#### TimeoutManager

```typescript
const timeoutManager = new TimeoutManager(
  TimeoutStrategy.ADAPTIVE,
  {
    global: 300000,      // 5 minute limitÄƒ totalÄƒ
    navigation: 30000,   // 30s pentru navigare
    networkIdle: 5000,   // 5s pentru network idle
    injection: 10000,    // 10s per payload
    verification: 15000, // 15s per verificare
    spaStabilization: 3000, // 3s pentru SPA settle
  }
);

// ExecuÈ›ie cu timeout handling
const { result, timedOut, duration } = await timeoutManager.executeWithTimeout(
  OperationType.INJECTION,
  async (signal) => {
    return await injector.inject(page, surface, payload, { signal });
  },
  { 
    onProgress: (p) => console.log(`${p.percentComplete}% complete`)
  }
);
```

#### Adaptive Learning

TimeoutManager Ã®nvaÈ›Äƒ din pattern-urile de rÄƒspuns:

```typescript
// MÄƒsoarÄƒ baseline automat
timeoutManager.recordSuccess(OperationType.API_REQUEST, 500); // 500ms

// AjusteazÄƒ timeout-uri pe baza rate-ului de timeout
if (timeoutRate > 0.1) {
  // CreÈ™te multiplier-ul automat
  multiplier *= 1.2; // max 2.0
}
```

#### SPAWaitStrategy

Strategii specifice pentru fiecare framework:

```typescript
const spaWait = new SPAWaitStrategy();

// DetecteazÄƒ framework-ul
const framework = await spaWait.detectFramework(page);
// Returns: 'angular' | 'react' | 'vue' | 'svelte' | 'unknown' | 'none'

// AÈ™teaptÄƒ stabilitate
const result = await spaWait.waitForStability(page, 5000);
/*
{
  isStable: true,
  framework: 'angular',
  stabilizationTime: 1200,
  passedConditions: ['angular-stable', 'dom-stability'],
  failedConditions: []
}
*/
```

#### Framework-Specific Wait Conditions

| Framework | CondiÈ›ie |
|-----------|----------|
| Angular | Zone.js stability (ngZone.isStable) |
| React | Scheduler idle / requestIdleCallback |
| Vue | Vue.nextTick completion |
| All | DOM mutation observer (200ms no changes) |

### Presets

```typescript
// Scan rapid
timeoutManager.usePreset('fast');
// global: 2 min, injection: 5s

// Standard
timeoutManager.usePreset('default');
// global: 5 min, injection: 10s

// Thorough (pentru audit complet)
timeoutManager.usePreset('thorough');
// global: 10 min, injection: 20s
```

## ğŸ“ Structura FiÈ™ierelor Noi

```
src/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ timeout/
â”‚   â”‚   â”œâ”€â”€ index.ts
â”‚   â”‚   â”œâ”€â”€ TimeoutManager.ts
â”‚   â”‚   â””â”€â”€ SPAWaitStrategy.ts
â”‚   â””â”€â”€ verification/
â”‚       â”œâ”€â”€ index.ts
â”‚       â”œâ”€â”€ VerificationEngine.ts
â”‚       â”œâ”€â”€ BaseVerifier.ts
â”‚       â””â”€â”€ techniques/
â”‚           â”œâ”€â”€ TimeBasedVerifier.ts
â”‚           â””â”€â”€ ResponseDiffVerifier.ts
â””â”€â”€ types/
    â”œâ”€â”€ verification.ts
    â””â”€â”€ timeout.ts
```

## ğŸ”§ Integrare

### Ãn Active Detectors

```typescript
// SqlInjectionDetector.ts
async detect(context: ActiveDetectorContext): Promise<Vulnerability[]> {
  const rawVulnerabilities = await this.findVulnerabilities(context);
  
  // v0.2: VerificÄƒ fiecare vulnerability
  const verificationEngine = getGlobalVerificationEngine();
  const verified = await verificationEngine.filterConfirmed(
    rawVulnerabilities,
    context.page,
    { level: VerificationLevel.STANDARD }
  );
  
  return verified;
}
```

### Ãn ActiveScanner

```typescript
// ActiveScanner.ts
public async execute(): Promise<ScanResult> {
  const timeoutManager = getGlobalTimeoutManager();
  const spaWait = getGlobalSPAWaitStrategy();
  
  // DetecteazÄƒ SPA È™i seteazÄƒ strategie
  await spaWait.detectFramework(page);
  
  for (const url of this.crawlQueue) {
    // Navigare cu timeout management
    const { timedOut } = await timeoutManager.executeWithTimeout(
      OperationType.NAVIGATION,
      async () => {
        await page.goto(url);
        await spaWait.waitForSPAReady(page);
      }
    );
    
    if (timedOut) {
      this.logger.warn(`Navigation timeout for ${url}, continuing...`);
      continue;
    }
    
    // ... rest of scan
  }
}
```

## ğŸ“ˆ Utilizare

### API Simplu

```typescript
import { 
  runActiveSecurityScan 
} from '@tzigger/kinetic/testing';

const vulnerabilities = await runActiveSecurityScan(page, {
  verification: {
    level: 'standard',      // 'none' | 'basic' | 'standard' | 'full'
    minConfidence: 0.7,
  },
  timeout: {
    strategy: 'adaptive',   // 'fixed' | 'adaptive' | 'spa-aware'
    preset: 'default',      // 'fast' | 'default' | 'thorough'
  },
});
```

### Statistici

```typescript
// Verificare statistici
const verificationStats = verificationEngine.getStatistics();
console.log(`Confirmed: ${verificationStats.confirmed}`);
console.log(`False Positives Eliminated: ${verificationStats.falsePositives}`);
console.log(`Average Confidence: ${verificationStats.averageConfidence}`);

// Timeout statistici
const timeoutStats = timeoutManager.getStatistics();
console.log(`Timeout Rate: ${(timeoutStats.timedOut / timeoutStats.totalOperations * 100).toFixed(1)}%`);
```

## ğŸ§ª Testing

### Unit Tests

```bash
npm test -- --grep "verification"
npm test -- --grep "timeout"
```

### Integration Tests

```bash
# Test pe Juice Shop (SPA Angular)
npm run test:juice-shop -- --verification-level=full

# Test cu timeout thorough
npm run test:vulnweb -- --timeout-preset=thorough
```

## ğŸ“ Next Steps (v0.3)

1. **DOM-based XSS Verifier** - Verificare prin Playwright dialog listener
2. **DNS Callback Verifier** - Pentru SSRF cu callback extern
3. **Parallel Verification** - Rulare tehnici Ã®n paralel pentru vitezÄƒ
4. **Machine Learning Confidence** - Model ML pentru scoring confidence
