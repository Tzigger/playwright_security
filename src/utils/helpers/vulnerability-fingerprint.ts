import crypto from 'crypto';

import { Vulnerability } from '../../types/vulnerability';
import { normalizeUrl } from './network-helpers';

function sha256(value: string): string {
  return crypto.createHash('sha256').update(value).digest('hex');
}

function getString(value: unknown): string {
  if (value === null || value === undefined) return '';
  if (typeof value === 'string') return value;
  if (typeof value === 'number' || typeof value === 'boolean') return String(value);
  try {
    return JSON.stringify(value);
  } catch {
    return String(value);
  }
}

/**
 * Generates a stable fingerprint for vulnerability de-duplication.
 *
 * Design goals:
 * - Stable across runs for the same finding
 * - Resistant to minor formatting differences
 * - Specific enough to not collapse distinct findings
 */
export function vulnerabilityFingerprint(vuln: Vulnerability): string {
  const requestUrl = vuln.evidence?.request?.url;
  const requestMethod = vuln.evidence?.request?.method;

  const primaryUrl = vuln.url || requestUrl || '';
  const normalizedUrl = primaryUrl ? normalizeUrl(primaryUrl) : '';

  const technique = getString((vuln.evidence?.metadata as any)?.technique);
  const surfaceName = getString((vuln.evidence?.metadata as any)?.surfaceName);

  const payload =
    vuln.evidence?.payload ??
    (vuln.evidence?.metadata as any)?.payload ??
    (typeof vuln.evidence?.request?.body === 'string' ? vuln.evidence.request.body : undefined);

  const payloadHash = payload ? sha256(getString(payload)) : '';

  const fingerprintMaterial = {
    category: vuln.category,
    cwe: vuln.cwe || '',
    owasp: vuln.owasp || '',
    title: vuln.title,
    url: normalizedUrl,
    requestMethod: requestMethod ? getString(requestMethod).toUpperCase() : '',
    technique,
    surfaceName,
    payloadHash,
  };

  return sha256(JSON.stringify(fingerprintMaterial));
}
